# 快速排序算法详解

快速排序是一种高效的排序算法，采用分治策略。下面我将详细解释快速排序的实现：

```python
def quick_sort(arr):
    # 基本情况：如果数组长度为0或1，已经是有序的
    if len(arr) <= 1:
        return arr
    
    # 选择基准值（pivot），这里选择中间元素
    pivot = arr[len(arr) // 2]
    
    # 将数组分为三部分：
    left = [x for x in arr if x < pivot]    # 小于基准值的元素
    middle = [x for x in arr if x == pivot] # 等于基准值的元素
    right = [x for x in arr if x > pivot]   # 大于基准值的元素
    
    # 递归排序左右部分，然后合并结果
    return quick_sort(left) + middle + quick_sort(right)
```

## 算法步骤解析

1. **基本情况处理**：如果数组长度≤1，直接返回（已经有序）

2. **选择基准值(pivot)**：
   - 这里选择中间元素作为基准值（`arr[len(arr)//2]`）
   - 也可以选择第一个、最后一个或随机元素作为基准值

3. **分区(Partition)**：
   - 将数组分为三个子数组：
     - `left`：所有小于基准值的元素
     - `middle`：所有等于基准值的元素
     - `right`：所有大于基准值的元素

4. **递归排序**：
   - 对`left`和`right`子数组递归调用快速排序
   - 将排序后的`left`、`middle`和`right`合并

## 时间复杂度

- 最佳/平均情况：O(n log n)
- 最坏情况（当选择的基准值总是最大或最小元素）：O(n²)
- 空间复杂度：O(n)（由于创建了新列表）

## 优化方向

1. 原地排序（不创建新列表）
2. 随机选择基准值
3. 对小数组使用插入排序
4. 三路快速排序（处理大量重复元素）

这个实现虽然简单直观，但创建了多个新列表，不是最优的空间效率实现。在实际应用中，通常会使用原地排序的版本。